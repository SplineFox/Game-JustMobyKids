<img src="https://github.com/SplineFox/Game-JustMobyKids/blob/master/ReadmeMedia/Just%20Moby%20Kids%20-%20Screenshot.png" width="50%">

# Тестовое задание JustMoby (Kids)
Затраченное время на выполнение **~16 часов**

## Зависимости
- DOTween
- Zenject
- UniRx

## Drag & Drop
Координатором всех взаимодействий с перетаскиваемыми элементами является `DragDropService`.
Логику работы данной системы можно разделить на:

### 1. Обработка ввода
`DragDropService` подписывается на события ввода от `InputService`.

### 2. Обнаружение IDragTarget
При нажатии на кнопку мыши система использует `RayHitProvider` для определения перетаскиваемого обьекта под курсором.
Система сканиурет объекты на слое «DragTarget» и проверяет, реализуют ли они `IDragTarget` со свойством `CanBeDragged`.

### 3. Проверка удержания и начало перетаскивания
Перетаскивание начинается после короткого удержания мыши на объекте. Для проверки старта перетаскивания используется `DragHoldDetector`, который проверяет время и допустимое смешение при удержании кнопки мыши. Если во время удержания пользователь совершает движение курсором, превышающее допустимое значение, то действие не фиксируется.

### 4. Обработка перетаскивания

При перетаскивании исходный обьект остаётся на месте, а вместо него используется "фантом" - обьект дублирующий визуальное представление без дополнительной логики. Каждый класс, реализующий `IDragTarget` должен возвращать своё представление "фантома". При этом исходный обьект способен реагировать на события события старта и окончания перетаскивания, чтобы давать обратную связь о своём состоянии. Например, он может изменять прозрачность или проигрывать анимацию.

### 5. Обнаружение IDropTarget
При отпускании мыши система использует `RayHitProvider` для проверки наличия под курсором `IDropTarget`. При успешном обнаружении у цели вызывается `OnDrop` с информацией о позиции сброса и `GameObject`, который задействовался при перетаскивании.

## Element
Класс `Element` представляет перетаскиваемые игровые объекты, реализующие интерфейс `IDragTarget`.
Каждому типу элемента соответсвует своя конфигурация `ElementConfiguration` (ScriptableObject), в которой указывается:
- id - для восстановления элемента из сохранений при перезапуске игры
- sprite - для установки уникального изображения
- прочие служебные свойства, например ключ текста локализации

Список всех конфигураций находится в `ElementConfigurationDatabase`(ScriptableObject). При восстановлении игры из сохранений он используется для получения конфигураций по id.
Для настройки количества элементов, используемых на уровне необходимо задать список конфигураций в `GameConfiguration`.

## ElementContainers
`ElementContainer` — это абстрактный базовый класс, определяющий, как контейнеры управляют своими элементами.
Существующие реализации:

### 1. Slot
`Slot` - представляет контейнеры с возобновляемыми элементами в области `ScrollArea`. Как только элемент из слота перетаскивается в другой контейнер, в слоте создаётся новый экземпляр. Слот запрещает уничтожение своих элементов, поэтому их нельзя перенести в `Hole`.

### 2. Tower
`Tower` - отвечает за зону с башенкой из элементов, реализует `IDropTarget`. Для своей работы использует:
- `ITowerAnimator` - обрабатывает анимацию размещения и удаления элементов
- `ITowerDropValidator` - проверяет возможность добавления элемента в башню при сбросе
- `ITowerPlacementProvider` - рассчитывает позиционирование элементов внутри башни при добавлении

При наличии сохранения восстанавлвиает состояние при инициализации.

### 3. Hole
`Hole` - отвечает за зону уничтожения элементов, реализует `IDropTarget`. При вызове OnDrop проверяет попадание курсора в `PolygonCollider` и анимирует сброс элемента в дыру.

## Saves
В игре реализована простая однофайловая система сохранения `SaveService` с использованием json.
Все обьекты, которые требуют сохранения должны реализовать интерфейс `ISaveObject`. Система сохранения содержит словарь экземпляров `SaveObjectContainer`, где каждый контейнер оборачивает объект `ISaveObject` сохранения с информацией о сериализации. Контейнеры необходимы из-за того, что сериализация интерфейсов требует дополнительных накладных расходов и менее надёжна.

`SaveInvoker` - автоматически запускает сохранение, когда приложение теряет фокус или приостанавливается.

## Localization
Для экономии времени и простоты понимания в игре реализована упрощённая система локализации, которая включает:

`LocalizationService` - предоставляет локализованный текст по ключу. Файлы локализации представлены в виде json-файлов. Для каждой локали используется свой файл в формате 'Localization_localeCode'.

`LocalizationLoader` - отвечает за загрузку файлов локализации в проекте. Для простоты демонстрации файлы добавлены в Resources. В боевых проектах файлы обычно загружаются через Addressables.

`LocalizationConfiguration` (ScriptableObject) - содержит локаль по умолчанию и список доступных языков. Для простоты локали указаны в виде обычных строк.

`LocalizationController` - отвечает за загрузку сохранённых языковых настроек при старте игры и сохранение изменений. В более крупных проектах логику инициализации языка выделяют в отдельную операцию, выполняемую при загрузке приложения. 

## Gameplay video
https://github.com/user-attachments/assets/98de0a12-d551-4ee0-976f-f420df0316e6
